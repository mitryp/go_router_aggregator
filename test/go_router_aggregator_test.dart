import 'package:build/build.dart';
import 'package:build_test/build_test.dart';
import 'package:go_router_aggregator/go_router_aggregator.dart';
import 'package:test/test.dart';

void main() {
  group('AggregateAppRoutesBuilder', () {
    test('emits nothing if no \$appRoutes getters are present', () async {
      // only a .g.dart but no $appRoutes inside
      final inputs = {
        'test|lib/unused.g.dart': '''
// some generated code without any \$appRoutes
void foo() {}
''',
      };

      await testBuilder(
        aggregateAppRoutes(const BuilderOptions({})),
        inputs,
        // Expect no outputs produced
        outputs: {},
      );
    });

    test('picks up a single route and generates lib/routes.g.dart', () async {
      final inputs = <String, String>{
        'test|lib/foo.g.dart': '''
// GENERATED - DO NOT MODIFY BY HAND
List<RouteBase> get \$appRoutes => [
  FooRoute(),
];
''',
        'test|lib/foo.dart': '''
import 'package:go_router/go_router.dart';
class FooRoute extends GoRouteData {
  const FooRoute();
  @override String get location => '/foo';
}
''',
      };

      // run with default options â†’ routes.g.dart
      await testBuilder(
        aggregateAppRoutes(const BuilderOptions({})),
        inputs,
        outputs: {
          'test|lib/routes.g.dart': decodedMatches(allOf(
            contains("// GENERATED by go_router_aggregator - do NOT edit by hand - contents will be overridden"),
            contains("import 'package:go_router/go_router.dart';"),
            contains("import 'package:test/foo.dart' as _foo0;"),
            contains("List<RouteBase> get \$aggregatedRoutes => ["),
            contains("..._foo0.\$appRoutes"),
          )),
        },
      );
    });

    test('respects a custom output path when passed via options', () async {
      final inputs = <String, String>{
        'test|lib/bar.g.dart': '''
List<RouteBase> get \$appRoutes => [BarRoute()];
''',
        'test|lib/bar.dart': '''
import 'package:go_router/go_router.dart';
class BarRoute extends GoRouteData {
  const BarRoute();
  @override String get location => '/bar';
}
''',
      };

      // tell the builder to write into lib/src/nav/app.dart
      final options = BuilderOptions({'output': 'src/nav/app.dart'});

      await testBuilder(
        aggregateAppRoutes(options),
        inputs,
        outputs: {
          'test|lib/src/nav/app.dart': decodedMatches(allOf(
            contains("import 'package:test/bar.dart' as _bar0;"),
            contains("..._bar0.\$appRoutes"),
          )),
        },
      );
    });

    test('aggregates multiple pages with routes', () async {
      final inputs = <String, String>{
        'test|lib/foo.g.dart': '''
// GENERATED
List<RouteBase> get \$appRoutes => [
  FooRoute(),
];
''',
        'test|lib/foo.dart': '''
import 'package:go_router/go_router.dart';
class FooRoute extends GoRouteData {
  const FooRoute();
  @override String get location => '/foo';
}
''',
        'test|lib/bar.g.dart': '''
// GENERATED
List<RouteBase> get \$appRoutes => [
  BarRoute(),
];
''',
        'test|lib/bar.dart': '''
import 'package:go_router/go_router.dart';
class BarRoute extends GoRouteData {
  const BarRoute();
  @override String get location => '/bar';
}
''',
      };

      await testBuilder(
        aggregateAppRoutes(const BuilderOptions({})),
        inputs,
        outputs: {
          'test|lib/routes.g.dart': decodedMatches(allOf(
            // it should declare the combined getter
            contains("List<RouteBase> get \$aggregatedRoutes => ["),
            // both imports must be present
            contains("import 'package:test/foo.dart' as _foo0;"),
            contains("import 'package:test/bar.dart' as _bar0;"),
            // and both spreads
            contains('..._foo0.\$appRoutes'),
            contains('..._bar0.\$appRoutes'),
          )),
        },
      );
    });
  });
}
